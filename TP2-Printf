// Guarda los registros que serán usados y el link register (LR).

printf:
    PUSH {R1-R12, LR}        // Registros a usar
    MOV R12, #0              // Contador de argumentos (número de enteros ya usados)

// Obtener caracter.
// Si es el último caracter → terminar impresión
// (no es el último caracter).
// Si no es ‘%’ → imprime caracter del registro del JTAG UART → obtener caracter. 
// Si es ‘%’ → si el siguiente no es ‘d’ → imprime caracter del registro del JTAG UART → obtener caracter.

next_char:
    LDRB R2, [R0], #1        // Cargar siguiente byte (char) y avanzar el puntero
    CMP R2, #0               // ¿Fin de cadena ('\0')?
    BEQ end_printf           // Si es fin, termina

    CMP R2, #'%'             // ¿Es '%'?
    BNE normal_char          // Si no, imprimir normalmente

    // Detectar formato (por el momento solo enteros %d)
    LDRB R3, [R0], #1        // Cargar siguiente carácter
    CMP R3, #'d'
    BNE normal_char          // Si no es 'd', imprimir '%' y R3 como normales

// (es ‘%’ y su siguiente es ‘d’).
// Carga el registro con el número según su aparición, es decir, si es el primer ‘%d’ se carga el primer número, si es el quinto ‘%d’, se carga el quinto número.

    CMP R12, #0
    MOVEQ R4, R1
    CMP R12, #1
    MOVEQ R4, R2
    CMP R12, #2
    MOVEQ R4, R3
    CMP R12, #3
    MOVEQ R4, R4
    CMP R12, #4
    MOVEQ R4, R5
    ADD R12, R12, #1         // Incrementar el contador de argumentos usados
    BL print_integer
    B next_char

// Imprimir número enviado al JTAG UART → obtener caracter.
normal_char:
    // Esperar que el UART esté listo para transmitir
wait_uart:
    LDR R5, =0xA0000004
    LDR R6, [R5]
    TST R6, #0xF0000000      // Verificar espacio disponible para escribir
    BEQ wait_uart     	// Si no hay, esperar

    // Escribir carácter
    LDR R5, =0xA0000004
    STR R2, [R5]

    B next_char

end_printf:
    POP {R1-R12, LR}
    BX LR

// Me compliqué mucho… asique asumí “numeros enteros positivos de 3 digitos”
print_integer:
    PUSH {R7-R9, LR}

    // R4 contiene el número a imprimir (0–999)

    MOV R7, R4         // Copia de R4
    MOV R8, #0         // Contador de centenas
centenas_loop:
    CMP R7, #99
    BGT do_centena
    B end_centenas
do_centena:
    SUB R7, R7, #100
    ADD R8, R8, #1
    B centenas_loop
end_centenas:
    ADD R2, R8, #'0'
    BL normal_char

    MOV R8, #0         // Contador de decenas
decenas_loop:
    CMP R7, #9
    BGT do_decena
    B end_decenas
do_decena:
    SUB R7, R7, #10
    ADD R8, R8, #1
    B decenas_loop
end_decenas:
    ADD R2, R8, #'0'
    BL normal_char

    // R7 ahora tiene las unidades
    ADD R2, R7, #'0'
    BL normal_char

    POP {R7-R9, LR}
    BX LR


